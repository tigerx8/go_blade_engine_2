package engine

import (
	"fmt"
	"html/template"
	"log"
	"os"
	"path/filepath"
	"strings"
	"sync"
	"time"
)

// CacheItem represents a cached template
type CacheItem struct {
	Template   *template.Template
	CreatedAt  time.Time
	LastUsedAt time.Time
	Size       int // Estimated size of the template
}

// CacheManager manages cached templates
type CacheManager struct {
	items           map[string]*CacheItem
	mutex           sync.RWMutex  // Protects concurrent access
	maxSize         int           // Maximum cache size (bytes)
	currentSize     int           // Current cache size (bytes)
	ttl             time.Duration // Time-to-live for cache items
	cleanupInterval time.Duration // Cleanup interval
	stopCleanup     chan bool     // Channel to stop cleanup routine
	cacheDir        string        // Directory to store cache files
}

// NewCacheManager creates a new CacheManager
func NewCacheManager(maxSizeMB int, ttlMinutes, cleanupMinutes int) *CacheManager {
	maxSize := maxSizeMB * 1024 * 1024 // Convert MB to bytes
	// Allow overriding cache directory via env var; otherwise use OS temp dir to avoid creating project-level ./cache
	cacheDir := os.Getenv("BLADE_CACHE_DIR")
	if cacheDir == "" {
		wd, err := os.Getwd()
		if err != nil {
			cacheDir = filepath.Join(os.TempDir(), "blade_cache")
		} else {
			cacheDir = filepath.Join(wd, "cache")
		}
	}
	// Create directory, but be tolerant if creation fails in constrained environments
	_ = os.MkdirAll(cacheDir, 0755)
	cm := &CacheManager{
		items:           make(map[string]*CacheItem),
		maxSize:         maxSize,
		ttl:             time.Duration(ttlMinutes) * time.Minute,
		cleanupInterval: time.Duration(cleanupMinutes) * time.Minute,
		stopCleanup:     make(chan bool),
		cacheDir:        cacheDir,
	}
	log.Println("Using cache directory: " + cacheDir)

	// Start cleanup routine
	go cm.startCleanupRoutine()

	return cm
}

// Get lấy template từ cache
func (cm *CacheManager) Get(key string) (*template.Template, bool) {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	if item, exists := cm.items[key]; exists {
		item.LastUsedAt = time.Now()
		return item.Template, true
	}

	return nil, false
}

// Set value or update cached template
func (cm *CacheManager) Set(key string, tmpl *template.Template, size int) error {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	// Check if cache is full
	if cm.currentSize+size > cm.maxSize {
		cm.evictOldItems()
	}

	// If still full after evicting, return error
	if cm.currentSize+size > cm.maxSize {
		return fmt.Errorf("cache is full, cannot add item")
	}

	cm.items[key] = &CacheItem{
		Template:   tmpl,
		CreatedAt:  time.Now(),
		LastUsedAt: time.Now(),
		Size:       size,
	}

	cm.currentSize += size
	// Previously we wrote a compiled file here. That caused layouts/components
	// to create .compiled files with incorrect content. Leave file cache
	// management to the Compiler which knows when to write compiled files.
	return nil
}

// CleanupCompiledForExtension removes any compiled cache files that originated from templates with the given extension
func (cm *CacheManager) CleanupCompiledForExtension(ext string) error {
	entries, err := os.ReadDir(cm.cacheDir)
	if err != nil {
		return err
	}
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		// The compiled file names are generated by replacing path separators with '_' and appending .compiled
		// Example: templates/layouts/app.blade.tpl -> layouts_app.blade.tpl.compiled
		// Remove file if its name contains the extension fragment (e.g. 'blade.tpl') or if it's empty
		if strings.Contains(name, strings.TrimPrefix(ext, ".")) {
			_ = os.Remove(filepath.Join(cm.cacheDir, name))
			continue
		}
		// Remove any zero-byte compiled files (likely leftovers)
		fi, err := entry.Info()
		if err == nil && fi.Size() == 0 && strings.HasSuffix(name, ".compiled") {
			_ = os.Remove(filepath.Join(cm.cacheDir, name))
		}
	}
	return nil
}

// CleanupLegacyCompiledForDirs removes compiled files whose names start with one of the provided directory prefixes
// e.g. layouts_app.blade.tpl.compiled -> prefix 'layouts'
func (cm *CacheManager) CleanupLegacyCompiledForDirs(dirs []string) error {
	entries, err := os.ReadDir(cm.cacheDir)
	if err != nil {
		return err
	}
	for _, entry := range entries {
		if entry.IsDir() {
			continue
		}
		name := entry.Name()
		for _, d := range dirs {
			if strings.HasPrefix(name, d+"_") && strings.HasSuffix(name, ".compiled") {
				_ = os.Remove(filepath.Join(cm.cacheDir, name))
				break
			}
		}
		// also remove zero-byte compiled files
		if fi, err := entry.Info(); err == nil && fi.Size() == 0 && strings.HasSuffix(name, ".compiled") {
			_ = os.Remove(filepath.Join(cm.cacheDir, name))
		}
	}
	return nil
}

// Remove removes a template from cache
func (cm *CacheManager) Remove(key string) {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	if item, exists := cm.items[key]; exists {
		cm.currentSize -= item.Size
		delete(cm.items, key)
		// Xóa file cache
		cacheFile := filepath.Join(cm.cacheDir, strings.ReplaceAll(key, string(os.PathSeparator), "_")+".compiled")
		_ = os.Remove(cacheFile)
	}
}

// Clear removes all items from cache
func (cm *CacheManager) Clear() {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	cm.items = make(map[string]*CacheItem)
	cm.currentSize = 0
	// Remove all cache files
	entries, _ := os.ReadDir(cm.cacheDir)
	for _, entry := range entries {
		if !entry.IsDir() {
			_ = os.Remove(filepath.Join(cm.cacheDir, entry.Name()))
		}
	}
}

// GetFileCache reads the content of the compiled cache file
func (cm *CacheManager) GetFileCache(key string) (string, bool) {
	cacheFile := filepath.Join(cm.cacheDir, strings.ReplaceAll(key, string(os.PathSeparator), "_")+".compiled")
	data, err := os.ReadFile(cacheFile)
	if err != nil {
		return "", false
	}
	return string(data), true
}

// evictOldItems removes old items to free up memory
func (cm *CacheManager) evictOldItems() {
	// Prioritize removing least recently used and oldest items
	var keysToRemove []string

	for key, item := range cm.items {
		// Check TTL
		if time.Since(item.CreatedAt) > cm.ttl {
			keysToRemove = append(keysToRemove, key)
			continue
		}

		// Check if not used in 2 TTLs
		if time.Since(item.LastUsedAt) > cm.ttl*2 {
			keysToRemove = append(keysToRemove, key)
		}
	}

	// Remove selected items
	for _, key := range keysToRemove {
		cm.currentSize -= cm.items[key].Size
		delete(cm.items, key)
	}
}

// startCleanupRoutine runs the periodic cache cleanup routine
func (cm *CacheManager) startCleanupRoutine() {
	ticker := time.NewTicker(cm.cleanupInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			cm.cleanupExpiredItems()
		case <-cm.stopCleanup:
			return
		}
	}
}

// cleanupExpiredItems removes expired items
func (cm *CacheManager) cleanupExpiredItems() {
	cm.mutex.Lock()
	defer cm.mutex.Unlock()

	now := time.Now()
	for key, item := range cm.items {
		if now.Sub(item.CreatedAt) > cm.ttl {
			cm.currentSize -= item.Size
			delete(cm.items, key)
		}
	}
}

// Stop stops the cleanup routine
func (cm *CacheManager) Stop() {
	close(cm.stopCleanup)
}

// Stats returns cache statistics
func (cm *CacheManager) Stats() map[string]interface{} {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	return map[string]interface{}{
		"total_items":     len(cm.items),
		"current_size_mb": cm.currentSize / (1024 * 1024),
		"max_size_mb":     cm.maxSize / (1024 * 1024),
		"memory_usage":    fmt.Sprintf("%.1f%%", float64(cm.currentSize)/float64(cm.maxSize)*100),
	}
}

// GetKeys returns a list of keys in the cache
func (cm *CacheManager) GetKeys() []string {
	cm.mutex.RLock()
	defer cm.mutex.RUnlock()

	keys := make([]string, 0, len(cm.items))
	for key := range cm.items {
		keys = append(keys, key)
	}
	return keys
}
